% btc_pairverify
% shows examples and verifies properties of textures generated by two specified parameters.
%
% creates a structure pvsum, that summarizes pairwise methods,
% indicating avaialble methods and extreme values that can be reached
%
% requires pmethsum, dict, and dict_def from workspace saved after running btc_surv, but it can be run
% at low search resolution
%
% added explicit call to btc_auxopts 24 Sep 12 so that number of metropolis
% iterations can be controlled, e.g., by 
% global metro_init_global
% metro_init_global.numiters=100;
%
%    See also: BTC_SURV, BTC_TEST, BTC_DEFINE, BTC_SHOWRAYS, BTC_EXPTNAME, BTC_COORKINDS, BTC_AUGCOORDS, MAPUBI.
%
if ~exist('btc_surv_filename')
    btc_surv_filename='btc_surv_13Aug09.mat';
end
btc_surv_filename=getinp('file name of workspace saved from btc_surv','s',[],btc_surv_filename);
s=load(btc_surv_filename);
pmethsum=getfield(s,'pmethsum');
dict=getfield(s,'dict');
dict_def=getfield(s,'dict_def');
clear s;
% table of direction of extreme coordinates, with first element at origin, then x-axis, then counterclockwise
extr_xdir=[0  1  1  0 -1 -1 -1  0  1];
extr_ydir=[0  0  1  1  1  0 -1 -1 -1];
%
if ~exist('mapsize')
    mapsize=[32 32];
end
if ~exist('nmaps')
    nmaps=1;
end
if ~exist('radfrac')
    radfrac=0.75;
end
if ~exist('ifshow')
    ifshow=1;
end
if ~exist('verbose')
    verbose=0;
end
mapsize(1)=getinp('sample map size (rows)','d',[1 1024],mapsize(1));
mapsize(2)=getinp('sample map size (cols)','d',[1 1024],mapsize(1));
nmaps=getinp('number of maps of each kind','d',[1 100],nmaps);
radfrac=getinp('fraction of distance to extreme paramater value','f',[0 1],radfrac);
ifshow=getinp('1 to show the first map of each set','d',[0 1],ifshow);
verbose=getinp('1 for verbose output from map generator, if applicable','d',[0 1],verbose);
%
opts_augcoords=[];
%
opts_makemaps=[];
opts_makemaps.show=0;
opts_makemaps.area= mapsize;
opts_makemaps.nmaps=nmaps;
opts_makemaps.verbose=verbose;
%
npar=2;
coordnums_list=nchoosek([1:length(dict.codel)],npar);
allowed_pairs=[];
disp(' id expt   method(s).....');
for icomb=1:size(coordnums_list,1)
    exptname=btc_exptname(dict.codel(coordnums_list(icomb,:)),dict);
    outstring=sprintf('%2.0f->%5s',icomb,exptname);
    if (isfield(pmethsum,exptname))
        allowed_pairs=[allowed_pairs,icomb];
        methods=getfield(pmethsum,exptname);
        for im=1:length(methods)
            outstring=cat(2,outstring,'   ',sprintf('%s %s',methods{im}.name,methods{im}.variant_lab));
        end
        disp(outstring);
    end
end
which_pairs=getinp('pairs to examine','d',[1 size(coordnums_list,1)]);
if ~isempty(setdiff(which_pairs,allowed_pairs));
    disp('the following disallowed pairs are removed.');
    disp(setdiff(which_pairs, allowed_pairs));
    which_pairs=intersect(which_pairs,allowed_pairs);
end
auxopts=btc_auxopts;
pvsum=[];
for icomb=which_pairs
    exptname=btc_exptname(dict.codel(coordnums_list(icomb,:)),dict);
    methods=getfield(pmethsum,exptname);
    for iv=1:npar
        icn(iv)=dict.codel(coordnums_list(icomb,iv));
    end
    ic=char(icn);
    maps=zeros(mapsize(1),mapsize(2),nmaps,9,length(methods)); % coord 3 is nmaps, coord 4 is extreme, coord 5 is method
    vecs=zeros(9,length(dict.codel),length(methods));
    vecs_emp=zeros(9,length(dict.codel),length(methods)); %for empirical vectors of probabilities
    entropy_mrfs=zeros(9,length(methods));
    entropy_mrfs_emp=zeros(9,length(methods));
    for im=1:length(methods)
        tstring=sprintf('%2.0f->%s %s %s',icomb,exptname,methods{im}.name,methods{im}.variant_lab);
        disp(cat(2,'processing ',tstring));
        for iextreme=0:8
            if (iextreme==0)
                xy=zeros(1,2);
            else
                xy=methods{im}.extremes(iextreme,:);
            end
            xy=xy*radfrac; %bring it in towards the origin
            spec=[];
            for iv=1:npar
                spec=setfield(spec,ic(iv),xy(iv));
            end
            rv=btc_augcoords(spec,dict,opts_augcoords);
            if (rv.method{im}.ok_norm==1) & (rv.method{im}.ok_probs==1)
                [maps(:,:,:,iextreme+1,im),ou,errs]=btc_makemaps(rv.method{im},opts_makemaps,dict,auxopts);
                vecs(iextreme+1,:,im)=rv.method{im}.vec;
                entropy_mrfs(iextreme+1,im)=rv.method{im}.entropy_mrf;
                if ~isempty(errs)
                    disp(sprintf('btc_makemaps finds an error for extreme %1.0f',iextreme));
                    spec
                    disp(errs);
                    disp(ou);
                end
                counts=zeros(2,2,2,2);
                for imap=1:nmaps
                    counts=counts+btc_map2counts(maps(:,:,imap,iextreme+1,im));
                end
                if sum(counts(:))==0 %this will happen if map is 1xn or nx1
                    counts=ones(2,2,2,2);
                end
                p2x2=counts/sum(counts(:));
                corrs=getcorrs_p2x2(p2x2);
                vecs_emp(iextreme+1,:,im)=btc_corrs2vec(corrs,dict_def);
                entropy_mrfs_emp(iextreme+1,im)=corrs.entropy;
            else
                disp(sprintf('btc_augcoords cannot find parameters for extreme %1.0f',iextreme));
                spec
                disp(rv.method{im})
            end
        end %iextreme
        if (ifshow)
            % now show the first map generated in each set
            figure;
            set(gcf,'Position',[200 200 800 800]);
            set(gcf,'NumberTitle','off');
            set(gcf,'Name',tstring);
            for iextreme=0:8
                subplot(3,3,5-3*extr_ydir(iextreme+1)+extr_xdir(iextreme+1));
                imagesc(maps(:,:,1,iextreme+1,im),[0 1]);
                axis equal;axis tight;colormap('gray');
                xlabel(sprintf('%2s=[%5.2f %5.2f]',ic,vecs(iextreme+1,coordnums_list(icomb,:),im)));
                set(gca,'XTick',[]);
                set(gca,'YTick',[]);
            end
        end %ifshow
        disp(sprintf('  maximum devs between empirical and desired coords: %8.5f entropy devs (valid for Pickard methods only): %8.5f',...
            max(max(abs(vecs_emp(:,:,im)-vecs(:,:,im)))),max(abs(entropy_mrfs(:,im)-entropy_mrfs_emp(:,im)))));
        a=[];
        a.maps=maps;
        a.vecs=vecs;
        a.vecs_emp=vecs_emp;
        a.entropy_mrfs=entropy_mrfs;
        a.entropy_mrfs_emp=entropy_mrfs_emp;
        %
        pvsum=setfield(pvsum,exptname,a);
    end %im
    clear a
end %icomb
clear ic icn icomb iextreme im iv tstring xy
clear corrs counts counts_map counts_ubi
clear maps vecs vecs_emp entropy_mrfs entropy_mrfs_emp
clear imap indices methods ou outstring p2x2
clear rv spec which_pairs
