% btc_pairdomain_sympick
% shows the domain of btc textures generated by alpha and gamma,
% but using alternate method as in btc_atg_alt_demo in addition to standard method.
%  See symmetric_pickard_notes.docx
%
% btc_pairdomain code borrowed, but simplified to apply only to fully symmetric Pickard rules
% 
% maps(:,:,imeth) are the final maps, have 0.5 where map is not generated
%
% texture parameters vary across the map, with a resolution determined by ruleupdate
%
%    See also: BTC_PAIRVERIFY, BTC_SURV, BTC_DEFINE, BTC_PAIRDOMAIN, BTC_ATG_ALT_DEMO, BTC_GETCOLOR, BTC_EXPTNAME.
% 
dict=btc_define;
npar=2;
%
if 0==getinp('1 for fast debug settings','d',[0 1],0);
    if ~exist('prange') prange=repmat([-1 1],npar,1); end %parameter range [lo hi] for each of two params
    if ~exist('mapsize') mapsize=128; end 
    if ~exist('ruleupdate') ruleupdate=1; end %resolution for updating the Markov process values
    if ~exist('nticks') nticks=3; end %tickmarks on map
    if ~exist('pale') pale=0.5; end
    if ~exist('pixelrep') pixelrep=4; end
    if ~exist('nsamps') nsamps=100; end
    if ~exist('mapformat') mapformat='png'; end
    mapsize=getinp('map size','d',[16 4096],mapsize);
    % make sure that ruleupdate is a factor of mapsize
    ruleupdate=-abs(ruleupdate); 
    while (ruleupdate<0)
        ruleupdate=getinp('resolution for updating the rule','d',[1 mapsize],abs(ruleupdate));
        if (mod(mapsize,ruleupdate)>0)
            ruleupdate=-ruleupdate;
            disp('resolution must be a factor of map size');
        end
    end
    nticks=getinp('number of ticks on map','d',[2 17],nticks);
    pale=getinp('pale multiplier for color background','f',[0 1],pale);
    pixelrep=getinp('pixel replication for saved maps (0 not to save)','d',[0 16],pixelrep);
    nsamps=getinp('search detail for b in maxent mode','d',[10 10000],nsamps);
    if (pixelrep>0)
        mapformat=getinp('map format (e.g., bmp or png)','s',[],mapformat);
        mapfilestub=getinp('map file name stub','s',[],'btc_sympick');
    end   
else
    prange=repmat([-1 1],npar,1);
    mapsize=64;
    ruleupdate=4;
    nticks=3;
    pale=0.1;
    pixelrep=0;
    nsamps=100; %search detail for b for maxent rule
end
grayback=getinp('>0 to use gray level of pale color for background','f',[0 1],0);
%
opts_augcoords=[];
opts_augcoords.ifstd=1;
opts_makemaps=[];
%
tickmat=[0:(nticks-1)]/(nticks-1);
tickmat=[fliplr(tickmat);tickmat];
%
npar=2;
nsteps=mapsize/ruleupdate;
%
%set up mapping of display coordinates (x,y) to btc coordinates ic(1),ic(2)
% x coordinate will display ic(itc(1)); y coordinate will display ic(itc(2))
ic='ga';
itc=[1 2];
prange=[-1 1;-1 1];
across_vals=prange(1,1)+(prange(1,2)-prange(1,1))*([1:nsteps]-0.5)/nsteps;
down_vals=prange(2,2)-(prange(2,2)-prange(2,1))*([1:nsteps]-0.5)/nsteps; %descending, from top of map
if (grayback==0)
    cnan=btc_getcolor(ic,setfield([],'pale',pale));
else
    cnan=repmat(grayback,1,3);
end
exptname=btc_exptname(ic,dict);
nmeths=2;
maps=zeros(mapsize,mapsize,nmeths);
p2x2s=zeros(2,2,2,2,nsteps,nsteps,nmeths);
bvals=[-nsamps:nsamps]/nsamps; 
for imeth=1:2
    switch imeth
        case 1
            methname='bg2';
        case 2
            methname='bmaxent';
    end
    tstring=sprintf('%s %s',exptname,methname);
    disp(cat(2,'processing ',tstring));
    if (pixelrep>0)
        mapfilename=cat(2,mapfilestub,'_',exptname,'_',methname,'.',mapformat);
        disp(sprintf(' saved map name will be %s',mapfilename));
    end
    %
    % set up coarse-grained coordinates, and then set up cell array of rv's from each
    %
    % arrays are set up so that they will display properly in standard call to imagesc
    %
    rv_method=cell(nsteps,nsteps);
    ifok=zeros(nsteps,nsteps);
    for across=1:nsteps
        for down=1:nsteps
            xy(1)=across_vals(across);
            xy(2)=down_vals(down);
            spec=struct;
            for ip=1:npar
                spec=setfield(spec,ic(itc(ip)),xy(ip));
            end
            % get the texture generation method for this step
            switch imeth
                case 1 %b=g^2,thet=g^3
                    rv=btc_augcoords(spec,dict,opts_augcoords);
                    p2x2=rv.method{1}.p2x2;
                    if all(p2x2>=0)
                        ifok(down,across)=1;
                        p2x2s(:,:,:,:,down,across,imeth)=p2x2;
                    end
                case 2 %search for a b that satisfies Pickard and is maxent
                    g=xy(1);
                    a=xy(2);
                    d_plus_u=(g+bvals).^2/(1+g);
                    d_minus_u=(g-bvals).^2/(1-g);
                    d=(d_plus_u+d_minus_u)/2;
                    u=(d_plus_u-d_minus_u)/2;
                    ent_max=-Inf;
                    for ib=1:length(bvals)
                        b=bvals(ib);
                        spec.b=b;
                        spec.c=b;
                        spec.d=d(ib);
                        spec.e=d(ib); 
                        spec.t=u(ib);
                        spec.u=u(ib);
                        spec.v=u(ib);
                        spec.w=u(ib);
                        vec=btc_letcode2vec(spec,dict);
                        corrs=btc_vec2corrs(vec,dict);
                        p2x2=getp2x2_corrs(corrs);
                        if all(p2x2(:)>=0)
                            corrs=getcorrs_p2x2(p2x2);
                            entropy=corrs.entropy;
                            if entropy>=ent_max
                                ifok(down,across)=1;
                                ent_max=entropy;
                                p2x2s(:,:,:,:,down,across,imeth)=p2x2;
                            end
                        end
                    end
            end
        end %down
    end %across
    disp('coarse-grain coordinates and rules are set up.');
    map=repmat(NaN,mapsize,mapsize); %set up the map
    %create the map, appropriate for NWSE
    steps=[0 1;1 0]; 
    begin=[0 0];
    begin_fine=[0 0];
    %  A B 
    %  C ?
    recurs=[1 1;1 0;0 1]; %A is at [row-1,col-1]; B is at [row-1, col], C is at [row, col-1]
    recurlet=[1 2 3]; % recursion knows about A, B, C
    pfield='p2x2';
    %vector values for upper left to lower right, appropriate for Pickard NWSE
    for ix2=0:nsteps-1
        for ix1=0:nsteps-1
            coarse_loc=begin+steps(1,:)*ix1+steps(2,:)*ix2;
            if (ifok(1+coarse_loc(1),1+coarse_loc(2))==1);
                p2x2=p2x2s(:,:,:,:,1+coarse_loc(1),1+coarse_loc(2),imeth);
                fine_loc=begin_fine+coarse_loc*ruleupdate;
                for jx2=0:ruleupdate-1;
                    for jx1=0:ruleupdate-1;
                        cur_loc=fine_loc+steps(1,:)*jx1+steps(2,:)*jx2;
                        %find positions of checks to be used for recurrence
                        posits=repmat(cur_loc,3,1)-recurs;
                        probs=p2x2;
                        for ipos=1:size(posits,1)
                            have_val=0;
                            if (any(posits(ipos,:)<0)) | (any(posits(ipos,:)>=mapsize))
                                have_val=NaN;
                            else
                                have_val=map(1+posits(ipos,1)+mapsize*posits(ipos,2));
                            end
                            %marginalize or select
                            if (isnan(have_val))
                                probs=sum(probs,recurlet(ipos));
                            else
                                if (recurlet(ipos)==1) probs=probs(have_val+1,:,:,:); end
                                if (recurlet(ipos)==2) probs=probs(:,have_val+1,:,:); end
                                if (recurlet(ipos)==3) probs=probs(:,:,have_val+1,:); end
                                if (recurlet(ipos)==4) probs=probs(:,:,:,have_val+1); end
                            end
                        end %ipos
                        probs=squeeze(probs);
                        map(1+cur_loc(1),1+cur_loc(2))=double((rand(1)*sum(probs))>probs(1));
                    end %jx1
                end %jx2
            end %rule is OK at coarse location
            %if (ifok(coarse_loc(1)+1,coarse_loc(2)+1)==1);
            %    map(fine_loc(1)+[1:ruleupdate],fine_loc(2)+[1:ruleupdate])=round(rand(ruleupdate,ruleupdate));
            %end
        end
    end
    map(find(isnan(map)))=0.5;
    maps(:,:,imeth)=map;
    %
    figure;
    % create a domain map
    set(gcf,'Position',[150 150 800 800]);
    set(gcf,'NumberTitle','off');
    set(gcf,'Name',cat(2,'map of domain for ',ic));
    cmap=colormap(gray(256));
    cmap_mod=cmap;
    cmap_mod(round(size(cmap,1)/2)+[-1:1],:)=repmat(cnan,3,1);
    colormap(cmap_mod);
    %
    across_vals_hr=prange(1,1)+(prange(1,2)-prange(1,1))*([1:mapsize]-0.5)/mapsize;
    down_vals_hr=prange(2,2)-(prange(2,2)-prange(2,1))*([1:mapsize]-0.5)/mapsize; %descending, from top of map
    tstring=cat(2,'domain for ',ic,', method: ',methname);
    imagesc(across_vals_hr,-down_vals_hr,map,[0 1]); hold on;
    title(tstring);
    tvals=prange;
    set(gca,'XLim',tvals(1,:));
    set(gca,'XTick',tvals(1,:)*tickmat)
    set(gca,'XTickLabel',tvals(1,:)*tickmat)
    set(gca,'YLim',-fliplr(tvals(2,:)));
    set(gca,'YTick',-fliplr(tvals(2,:))*tickmat);
    set(gca,'YTickLabel',fliplr(tvals(2,:))*tickmat);
    xlabel(ic(itc(1)));
    ylabel(ic(itc(2)));
    axis square;
    if (pixelrep>0)
        imwrite(reppxl(map*256,[pixelrep pixelrep]),cmap_mod,mapfilename,mapformat);
        disp(sprintf('map %s written.',mapfilename));
    end
end %imeth
