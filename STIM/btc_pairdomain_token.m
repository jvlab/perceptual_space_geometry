% btc_pairdomain_token
% shows the domain of btc textures generated by two specified parameters,
% both standard and token.
% texture parameters vary across the map, with a resolution determined by ruleupdate
%
% a bit of restructuring since in btc_pairdomain, pixelrep was also used to
% control whether a map file is written
%
%    See also: BTC_PAIRVERIFY, BTC_SURV, BTC_TEST, BTC_DEFINE, BTC_SHOWRAYS,BTC_GETCOLOR,
%    BTC_EXPTNAME, BTC_COORKINDS, BTC_AUGCOORDS, MAPUBI, GENMRFM,
%    MET_VSS05_ATG, BTC_PAIRDOMAIN, TOKEN_MAP, BTC_TOKEN_DEMO, BTC_TOKEN_DEMO2, REP_LINE_REG.
%
if ~exist('btc_surv_filename')
    btc_surv_filename='btc_surv_13Aug09.mat';
end
btc_surv_filename=getinp('file name of workspace saved from btc_surv','s',[],btc_surv_filename);
s=load(btc_surv_filename);
pmethsum=getfield(s,'pmethsum');
dict=getfield(s,'dict');
dict_def=getfield(s,'dict_def');
clear s;
%
npar=2;
%
settings{1}.name='16 x 16';
settings{1}.mapsize=16;
settings{1}.ruleupdate=1;
settings{2}.name='32 x 32';
settings{2}.mapsize=32;
settings{2}.ruleupdate=1;
settings{3}.name='64 x 64, coarse';
settings{3}.mapsize=64;
settings{3}.ruleupdate=2;
settings{4}.name='64 x 64, fine';
settings{4}.mapsize=64;
settings{4}.ruleupdate=1;
settings{5}.name='128 x 128, coarse';
settings{5}.mapsize=128;
settings{5}.ruleupdate=4;
settings{6}.name='128 x 128, fine';
settings{6}.mapsize=128;
settings{6}.ruleupdate=1;
for k=1:length(settings)
    disp(sprintf('%2.0f->%s',k,settings{k}.name));
    disp(settings{k});
end
iset=getinp('choice','d',[1 length(settings)]);
if ~exist('pixelrep') pixelrep=10; end
pixelrep=getinp('pixel replication (and token size)','d',[2 24],pixelrep);
mapsize=settings{iset}.mapsize;
ruleupdate=settings{iset}.ruleupdate;
if 0==getinp('1 for debug mode (less questions)','d',[0 1]);
    if ~exist('if_savemap') if_savemap=1; end
    if ~exist('prange') prange=repmat([-1 1],npar,1); end %parameter range [lo hi] for each of two params
    if ~exist('nticks') nticks=3; end %tickmarks on map
    if ~exist('verbose') verbose=0; end
    if ~exist('if_plotd') if_plotd=0; end
    if ~exist('if_plotc') if_plotc=0; end
    if ~exist('if_plotm') if_plotm=1; end
    if ~exist('pale') pale=0.5; end
    if ~exist('mapformat') mapformat='png'; end
    mapsize=getinp('map size','d',[16 2048],mapsize);
    % make sure that ruleupdate is a factor of mapsize
    ruleupdate=-abs(ruleupdate); 
    while (ruleupdate<0)
        ruleupdate=getinp('resolution for updating the rule','d',[1 mapsize],abs(ruleupdate));
        if (mod(mapsize,ruleupdate)>0)
            ruleupdate=-ruleupdate;
            disp('resolution must be a factor of map size');
        end
    end
    nticks=getinp('number of ticks on map','d',[2 17],nticks);
    verbose=getinp('1 for verbose output from map generator, if applicable','d',[0 1],verbose);
    if_plotd=getinp('1 to plot domain requested','d',[0 1],if_plotd);
    if_plotc=getinp('1 to plot coordinates','d',[0 1],if_plotc);
    if_plotm=getinp('1 to plot maps','d',[0 1],if_plotm);
    pale=getinp('pale multiplier for color background','f',[0 1],pale);
    if_savemap=getinp('1 to save the map','d',[0 1],if_savemap);
    if (if_savemap>0)
        mapformat=getinp('map format (e.g., bmp or png)','s',[],mapformat);
        mapfilestub=strrep(btc_surv_filename(1:find(btc_surv_filename=='.')-1),'surv','domain');
        mapfilestub=getinp('map file name stub','s',[],mapfilestub);
    end   
else
    if_savemap=0;
    prange=repmat([-1 1],npar,1);
    nticks=3;
    verbose=0;
    if_plotd=1;
    if_plotc=1;
    if_plotm=1;
    pale=0.1;
end
grayback=getinp('between 0 and 1 to use a gray level of pale color for background','f',[0 1],.5);
%
opts_augcoords=[];
opts_augcoords.ifstd=1;
opts_makemaps=[];
%
tickmat=[0:(nticks-1)]/(nticks-1);
tickmat=[fliplr(tickmat);tickmat];
%
coordnums_list=nchoosek([1:length(dict.codel)],npar);
allowed_pairs=[];
disp(' id expt   method(s).....');
for icomb=1:size(coordnums_list,1)
    exptname=btc_exptname(dict.codel(coordnums_list(icomb,:)),dict);
    outstring=sprintf('%2.0f->%5s',icomb,exptname);
    if (isfield(pmethsum,exptname))
        allowed_pairs=[allowed_pairs,icomb];
        methods=getfield(pmethsum,exptname);
        for imeth=1:length(methods)
            outstring=cat(2,outstring,'   ',sprintf('%s %s',methods{imeth}.name,methods{imeth}.variant_lab));
        end
        disp(outstring);
    end
end
which_pairs=[];
while isempty(which_pairs)
    which_pairs=getinp('parameter pair(s) to use','d',[1 size(coordnums_list,1)]);
    which_pairs=intersect(which_pairs,allowed_pairs);
    if (isempty(which_pairs))
        disp('none of these are allowed pairs');
    end
end
pvsum=[];
npar=2;
nsteps=mapsize/ruleupdate;
%
%get token information (simplified from btc_token_gamut)
%
token_size=pixelrep;
presets{1}.name='pair NESW, NWSE, which makes diamonds, black lines on white regions';
presets{1}.specs{1}.shape='pair_NESW';
presets{1}.specs{1}.params=[0 1];
presets{1}.specs{2}.shape='pair_NWSE';
presets{1}.specs{2}.params=[0 1];
presets{2}.name='arcs NESW, NWSE, which makes circles, black lines on white regions';
presets{2}.specs{1}.shape='arcs_NESW';
presets{2}.specs{1}.params=[0 1];
presets{2}.specs{2}.shape='arcs_NWSE';
presets{2}.specs{2}.params=[0 1];
%
% set up the token choice, as in token_map_demo, but force use of presets
%
ifok=0;
while (ifok==0)
    for ip=1:length(presets)
        disp(sprintf('%2.0f->%s',ip,presets{ip}.name))
    end
    imeth=getinp('choice','d',[1 length(presets)]);
    token_specs=presets{imeth}.specs;
    opts_rll=[];
    if_rll=getinp('1 to fill in the regions','d',[0 1]);
    if (if_rll==1)
        region_val=getinp('value representing a region in original map (1=white)','d',[0 1],1);
        opts_rll.region_val=region_val;
    end
    for itok=1:2
        disp(sprintf('token descriptor %1.0f',itok));
        disp(token_specs{itok});
    end
    figure;
    set(gcf,'NumberTitle','off');
    set(gcf,'Name','token sample');
    set(gcf,'Position',[150 150 800 600]);
    tokens_chosen=cell(1,2);
    for iexamp=1:2
        for itok=1:2
            imap=itok+2*(iexamp-1);
            tokens_chosen{imap}=token_map((itok-1)*ones(iexamp),token_size,token_specs);
            if (if_rll)
                tokens_chosen{imap}=rep_line_reg(tokens_chosen{imap},opts_rll);
            end
            subplot(2,4,itok+4*(iexamp-1));
            imagesc(tokens_chosen{imap},[0 1]);
            colormap gray;
            axis square;
            axis off;
            title(sprintf('%1.0fx%1.0f , pxl%1.0f-> %s %4.2f %4.2f',...
                iexamp,iexamp,itok-1,token_specs{itok}.shape,token_specs{itok}.params(1:2)),...
                'Interpreter','none','FontSize',7);
        end
    end
    imap=5;
    tokens_chosen{imap}=token_map(round(rand(8,8)),token_size,token_specs);
    if (if_rll)
        tokens_chosen{imap}=rep_line_reg(tokens_chosen{imap},opts_rll);
    end
    subplot(1,2,2);
    imagesc(tokens_chosen{imap},[0 1]);
    colormap gray;
    axis square;
    axis off;
    title('sample of a random map');
    %
    ifok=getinp('1 if OK','d',[0 1]);
end
%
%make the maps
%
for ipair=1:length(which_pairs)
    which_pair=which_pairs(ipair);
    exptname=btc_exptname(dict.codel(coordnums_list(which_pair,:)),dict);
    methods=getfield(pmethsum,exptname);
    for iv=1:npar
        icn(iv)=dict.codel(coordnums_list(which_pair,iv));
    end
    ic=char(icn);
    %set up mapping of display coordinates (x,y) to btc coordinates ic(1),ic(2)
    % x coordinate will display ic(itc(1)); y coordinate will display ic(itc(2))
    if (ipair==1)
        itc=[];
        for ip=1:npar
            if (ip==1)
                disp(' texture coordinate to be mapped across the image for first pair (values increasing from left to right)');
            else
                disp(' texture coordinate to be mapped down the image for first pair (values increasing from bottom to top)');
            end
            avail=setdiff([1:npar],itc);
            itc(ip)=getinp(sprintf('1->%s,2->%s',ic(1),ic(2)),'d',[min(avail) max(avail)],min(avail));
            prange(ip,:)=getinp(sprintf('range for parameter %1.0f (%s) [enter two values if nondefault]',...
                ip,ic(itc(ip))),'f',[-1 1],prange(ip,:));
        end
        across_vals=prange(1,1)+(prange(1,2)-prange(1,1))*([1:nsteps]-0.5)/nsteps;
        down_vals=prange(2,2)-(prange(2,2)-prange(2,1))*([1:nsteps]-0.5)/nsteps; %descending, from top of map
    end
    if (grayback==0)
        cnan=btc_getcolor(ic,setfield([],'pale',pale));
    else
        cnan=repmat(grayback,1,3);
    end
    imeth=1;
    %
    tstring=sprintf('%2.0f->%s %s %s',which_pair,exptname,methods{imeth}.name,methods{imeth}.variant_lab);
    disp(cat(2,'processing ',tstring));
    if (if_savemap>0)
        mapfilename{1}=cat(2,mapfilestub,'_',exptname,'.',mapformat);
        mapfilename{2}=cat(2,mapfilestub,'_',exptname,'_token.',mapformat);
        disp(sprintf(' saved map names will be %s and %s',mapfilename{1},mapfilename{2}));
    end
    %
    % set up coarse-grained coordinates, and then set up cell array of rv's from each
    %
    % arrays are set up so that they will display properly in 
    % standard call to imagesc
    %
    rv_method=cell(nsteps,nsteps);
    ifok=zeros(nsteps,nsteps);
    btc_vals=zeros(nsteps,nsteps,length(dict.codel));
    for across=1:nsteps
        for down=1:nsteps
            spec=[];
            xy(1)=across_vals(across);
            xy(2)=down_vals(down);
            for ip=1:npar
                spec=setfield(spec,ic(itc(ip)),xy(ip));
            end
            rv=btc_augcoords(spec,dict,opts_augcoords);
            % get the texture generation method for this step
            rv_method{down,across}=rmfield(rv.method{imeth},{'letcode','corrs','cig_conds'});
            if (rv_method{down,across}.ok_norm==1) & (rv_method{down,across}.ok_probs==1)
                ifok(down,across)=1;
            end
            xparam(down,across)=xy(1);
            yparam(down,across)=xy(2);
            btc_vals(down,across,:)=rv_method{down,across}.vec;
        end %down
    end %across
    disp('coarse-grain coordinates and rules are set up.');
    map=repmat(NaN,mapsize,mapsize); %set up the map
    %create the map
    method_name=rv_method{1,1}.name;
    method_variant_num=rv_method{1,1}.variant_num;
    method_variant_lab=rv_method{1,1}.variant_lab;
    switch method_name
        case 'Pickard'
            nrot=NaN; %rotations done here
            %appropriate for NWSE
            steps=[0 1;1 0]; 
            begin=[0 0];
            begin_fine=[0 0];
            %  A B 
            %  C ?
            recurs=[1 1;1 0;0 1]; %A is at [row-1,col-1]; B is at [row-1, col], C is at [row, col-1]
            recurlet=[1 2 3]; % recursion knows about A, B, C
            pfield='p2x2';
            %appropriate for NESW
            if (method_variant_num==2)
                steps=[0 -1;1 0];
                begin=[0 nsteps-1];
                begin_fine=[0 ruleupdate-1];
                %  A B 
                %  ? D
                recurs=[1 0;1 -1;0 -1];
                recurlet=[1 2 4]; % recursion knows about A, B, D
                pfield='p2x2';
            end
        case 'DiagMRF'
            nrot=NaN; %rotations done ere
            %    B
            %   A D 
            %    ?
            steps=[0 1;1 0]; 
            begin=[0 0];
            begin_fine=[0 0];
            recurs=[1 1;2 0;1 -1]; % recursion knows about A, B, D
            recurlet=[1 2 4]; % recursion knows about A, B, C
            pfield='diagp2x2';
        case 'NoPickTT'
            nrot=method_variant_num-1; %rotations done below
            %appropriate for rot1
            steps=[0 1;1 0]; 
            begin=[0 0];
            begin_fine=[0 0];
            recurs=[1 1;1 0;0 1]; %A is at [row-1,col-1]; B is at [row-1, col], C is at [row, col-1]
            %  A B 
            %  C ?
            if (nrot==0) recurlet=[1 2 3];end % recursion knows about A, B, C
            %  A ? 
            %  C D
            if (nrot==1) recurlet=[3 1 4];end % recursion knows about C, A, D
            %  ? B 
            %  C D
            if (nrot==2) recurlet=[4 3 2];end % recursion knows about D, C, B
            %  A B 
            %  ? D
            if (nrot==3) recurlet=[2 4 1];end % recursion knows about B, D, A
            pfield='p2x2';
        case 'NoPickBT'
            nrot=method_variant_num-1; %rotations done below
            %appropriate for rot1
            steps=[0 1;1 0]; 
            begin=[0 0];
            begin_fine=[0 0];
            %  from genmrfm_tee
            %   A B C
            %     ?
            recurs=[1 1;1 0;1 -1]; %A is at [row-1,col-1]; B is at [row-1, col], C is at [row-1, col+1]
            recurlet=[1 2 3]; % recursion knows about A, B, C
            pfield='teeprobs';
    end
    if (nrot>0) %rot=0: no rotation; 
        for irot=1:nrot
            %begin(1)=nsteps-1-begin(2);
            %begin(2)=begin(1);
            begin=[nsteps-1 0]+[-1 1].*fliplr(begin);
            begin_fine=[ruleupdate-1 0]+[-1 1].*fliplr(begin_fine);
            steps=steps*[0 1;-1 0];
            recurs=recurs*[0 1;-1 0];
        end
    end
    %vector values for upper left to lower right, appropriate for Pickard NWSE
    for ix2=0:nsteps-1
        for ix1=0:nsteps-1
            coarse_loc=begin+steps(1,:)*ix1+steps(2,:)*ix2;
            if (ifok(1+coarse_loc(1),1+coarse_loc(2))==1);
                p2x2=getfield(rv_method{1+coarse_loc(1),1+coarse_loc(2)},pfield);
                fine_loc=begin_fine+coarse_loc*ruleupdate;
                for jx2=0:ruleupdate-1;
                    for jx1=0:ruleupdate-1;
                        cur_loc=fine_loc+steps(1,:)*jx1+steps(2,:)*jx2;
                        %find positions of checks to be used for recurrence
                        posits=repmat(cur_loc,3,1)-recurs;
                        probs=p2x2;
                        for ipos=1:size(posits,1)
                            have_val=0;
                            if (any(posits(ipos,:)<0)) | (any(posits(ipos,:)>=mapsize))
                                have_val=NaN;
                            else
                                have_val=map(1+posits(ipos,1)+mapsize*posits(ipos,2));
                            end
                            %marginalize or select
                            if (isnan(have_val))
                                probs=sum(probs,recurlet(ipos));
                            else
                                if (recurlet(ipos)==1) probs=probs(have_val+1,:,:,:); end
                                if (recurlet(ipos)==2) probs=probs(:,have_val+1,:,:); end
                                if (recurlet(ipos)==3) probs=probs(:,:,have_val+1,:); end
                                if (recurlet(ipos)==4) probs=probs(:,:,:,have_val+1); end
                            end
                        end %ipos
                        probs=squeeze(probs);
                        map(1+cur_loc(1),1+cur_loc(2))=double((rand(1)*sum(probs))>probs(1));
                    end %jx1
                end %jx2
            end %rule is OK at coarse location
            %if (ifok(coarse_loc(1)+1,coarse_loc(2)+1)==1);
            %    map(fine_loc(1)+[1:ruleupdate],fine_loc(2)+[1:ruleupdate])=round(rand(ruleupdate,ruleupdate));
            %end
        end
    end
    map(find(isnan(map)))=0.5;
    %
    if (if_plotd==1)
        %plot some setup info
        figure;
        set(gcf,'Position',[100 150 1200 800]);
        set(gcf,'NumberTitle','off');
        set(gcf,'Name',cat(2,'accessible region for ',ic));
        % create a color map in which the inner half is a color scale, bottom is white, top is black
        cmap=colormap(jet(256));
        cmap_bw=[ones(size(cmap,1)/4,3);cmap([1:2:size(cmap,1)-1],:);zeros(size(cmap,1)/4,3)];
        colormap(cmap_bw);
        %
        %plotting is tricky:  want to use default YDir='reverse' for imagesc, but want the parameter
        %values to be largest at top of map, which is row 1, so we flip and negate the y-values for plotting
        %
        for whichplot=1:3
            for inner=1:2
                subplot(2,3,whichplot+3*(inner-1));
                switch whichplot
                    case 1
                        tstring='ifok';
                        v=ifok;
                        zrange=[0 1];
                    case 2
                        tstring='xparam';
                        v=xparam*0.5; %the inner half is mapped to a color scale
                        zrange=[-1 1];
                    case 3
                        tstring='yparam';
                        v=yparam*0.5; %the inner half is mapped to a color scale
                        zrange=[-1 1];
                end
                imagesc(across_vals,-down_vals,v,zrange); hold on;
                title(tstring);
                if (inner==1)
                    tvals=prange;
                else
                    tvals=[-1 1;-1 1];
                end
                set(gca,'XLim',tvals(1,:));
                set(gca,'XTick',tvals(1,:)*tickmat)
                set(gca,'XTickLabel',tvals(1,:)*tickmat)
                set(gca,'YLim',-fliplr(tvals(2,:)));
                set(gca,'YTick',-fliplr(tvals(2,:))*tickmat);
                set(gca,'YTickLabel',fliplr(tvals(2,:))*tickmat);
                xlabel(ic(itc(1)));
                ylabel(ic(itc(2)));
                axis square;
            end %inner
        end %whichplot
    end %if_plotd
    %
    if (if_plotc)
        figure;
        % create a color map in which the inner half is a color scale, bottom is white, top is black
        set(gcf,'Position',[100 150 1200 800]);
        set(gcf,'NumberTitle','off');
        set(gcf,'Name',cat(2,'coordinate values for ',ic));
        cmap=colormap(jet(256));
        cmap_bw=[ones(size(cmap,1)/4,3);cmap([1:2:size(cmap,1)-1],:);zeros(size(cmap,1)/4,3)];
        colormap(cmap_bw);
        [nr,nc]=nicesubp(length(dict.codel),0.7);
        for iparam=1:length(dict.codel)
            subplot(nr,nc,iparam);
            tstring=sprintf('value of %s',dict.codel(iparam));
            % show coordinate value if ifok=1, otherwise, -1
            v=ifok.*btc_vals(:,:,iparam)*0.5+ifok-1; %ifok=1: btc_vals*0.5; otherwise, -1
            zrange=[-1 1];
            imagesc(across_vals,-down_vals,v,zrange); hold on;
            title(tstring);
            tvals=prange;
            set(gca,'XLim',tvals(1,:));
            set(gca,'XTick',tvals(1,:)*tickmat)
            set(gca,'XTickLabel',tvals(1,:)*tickmat)
            set(gca,'YLim',-fliplr(tvals(2,:)));
            set(gca,'YTick',-fliplr(tvals(2,:))*tickmat);
            set(gca,'YTickLabel',fliplr(tvals(2,:))*tickmat);
            xlabel(ic(itc(1)));
            ylabel(ic(itc(2)));
            axis square;
        end
    end %if_plotc
    %
    % replicate each map check to prepare for tokens
    map_replic=reppxl(map,[pixelrep pixelrep]);
    %create a new map in which checks are replaced by tokens 
    %need to deal with regions that are outside the domain
    mapz=map;
    mapz(find(map==0.5))=0; %to enable token replacement
    map_token=token_map(mapz,token_size,token_specs);
    if (if_rll)
        map_token=rep_line_reg(map_token,opts_rll);
    end
    map_token(map_replic==0.5)=0.5;
    if (if_plotm)
        for if_tok=0:1
            if (if_tok==0)
                map_active=map_replic;
                tstring=cat(2,'domain for ',ic);
            else
                map_active=map_token;
                tstring=cat(2,'domain for ',ic,' tokens');
            end
            figure;
            % create a domain map
            set(gcf,'Position',[150 150 800 800]);
            set(gcf,'NumberTitle','off');
            set(gcf,'Name',cat(2,'map of ',tstring));
            cmap=colormap(gray(256));
            cmap_mod=cmap;
            cmap_mod(round(size(cmap,1)/2)+[-1:1],:)=repmat(cnan,3,1);
            colormap(cmap_mod);
            %
            across_vals_hr=prange(1,1)+(prange(1,2)-prange(1,1))*([1:mapsize*pixelrep]-0.5)/(mapsize*pixelrep);
            down_vals_hr=prange(2,2)-(prange(2,2)-prange(2,1))*([1:mapsize*pixelrep]-0.5)/mapsize/pixelrep; %descending, from top of map

            imagesc(across_vals_hr,-down_vals_hr,map_active,[0 1]); hold on;
            title(tstring);
            tvals=prange;
            set(gca,'XLim',tvals(1,:));
            set(gca,'XTick',tvals(1,:)*tickmat)
            set(gca,'XTickLabel',tvals(1,:)*tickmat)
            set(gca,'YLim',-fliplr(tvals(2,:)));
            set(gca,'YTick',-fliplr(tvals(2,:))*tickmat);
            set(gca,'YTickLabel',fliplr(tvals(2,:))*tickmat);
            xlabel(ic(itc(1)));
            ylabel(ic(itc(2)));
            axis square;
            if (if_savemap>0)
                imwrite(map_active*256,cmap_mod,mapfilename{if_tok+1},mapformat);
                disp(sprintf('map %s written.',mapfilename{if_tok+1}));
            end
        end %if_tok 
    end %if_plotm
end %ipair
%
clear inner whichplot v tstring zrange tvals xy 
clear spec outstring across down iparam nr nc ipair
clear iv ix1 ix2 jx1 jx2 ipos
clear coarse_loc fine_loc have_vals

