% btc_pairdomain
% shows the domain of btc textures generated by two specified parameters.
% texture parameters vary across the map, with a resolution determined by ruleupdate
%
%    See also: BTC_PAIRVERIFY, BTC_SURV, BTC_TEST, BTC_DEFINE, BTC_SHOWRAYS,BTC_GETCOLOR,
%    BTC_EXPTNAME, BTC_COORKINDS, BTC_AUGCOORDS, MAPUBI, GENMRFM, MET_VSS05_ATG, BTC_PAIRDOMAIN_TOKEN.
%
if ~exist('btc_surv_filename')
    btc_surv_filename='btc_surv_13Aug09.mat';
end
btc_surv_filename=getinp('file name of workspace saved from btc_surv','s',[],btc_surv_filename);
s=load(btc_surv_filename);
pmethsum=getfield(s,'pmethsum');
dict=getfield(s,'dict');
dict_def=getfield(s,'dict_def');
clear s;
%
npar=2;
%
if 0==getinp('debug settings','d',[0 1]);
    if ~exist('prange') prange=repmat([-1 1],npar,1); end %parameter range [lo hi] for each of two params
    if ~exist('mapsize') mapsize=128; end 
    if ~exist('ruleupdate') ruleupdate=1; end %resolution for updating the Markov process values
    if ~exist('nticks') nticks=3; end %tickmarks on map
    if ~exist('verbose') verbose=0; end
    if ~exist('if_plotd') if_plotd=0; end
    if ~exist('if_plotc') if_plotc=0; end
    if ~exist('if_plotm') if_plotm=1; end
    if ~exist('pale') pale=0.5; end
    if ~exist('pixelrep') pixelrep=4; end
    if ~exist('mapformat') mapformat='png'; end
    mapsize=getinp('map size','d',[16 2048],mapsize);
    % make sure that ruleupdate is a factor of mapsize
    ruleupdate=-abs(ruleupdate); 
    while (ruleupdate<0)
        ruleupdate=getinp('resolution for updating the rule','d',[1 mapsize],abs(ruleupdate));
        if (mod(mapsize,ruleupdate)>0)
            ruleupdate=-ruleupdate;
            disp('resolution must be a factor of map size');
        end
    end
    nticks=getinp('number of ticks on map','d',[2 17],nticks);
    verbose=getinp('1 for verbose output from map generator, if applicable','d',[0 1],verbose);
    if_plotd=getinp('1 to plot domain requested','d',[0 1],if_plotd);
    if_plotc=getinp('1 to plot coordinates','d',[0 1],if_plotc);
    if_plotm=getinp('1 to plot maps','d',[0 1],if_plotm);
    pale=getinp('pale multiplier for color background','f',[0 1],pale);
    pixelrep=getinp('pixel replication for saved maps (0 not to save)','d',[0 16],pixelrep);
    if (pixelrep>0)
        mapformat=getinp('map format (e.g., bmp or png)','s',[],mapformat);
        mapfilestub=strrep(btc_surv_filename(1:find(btc_surv_filename=='.')-1),'surv','domain');
        mapfilestub=getinp('map file name stub','s',[],mapfilestub);
    end   
else
    prange=repmat([-1 1],npar,1);
    mapsize=64;
    ruleupdate=4;
    nticks=3;
    verbose=0;
    if_plotd=1;
    if_plotc=1;
    if_plotm=1;
    pale=0.1;
    pixelrep=0;
end
grayback=getinp('>0 to usea  gray level of pale color for background','f',[0 1],0);
%
opts_augcoords=[];
opts_augcoords.ifstd=1;
opts_makemaps=[];
%
tickmat=[0:(nticks-1)]/(nticks-1);
tickmat=[fliplr(tickmat);tickmat];
%
coordnums_list=nchoosek([1:length(dict.codel)],npar);
allowed_pairs=[];
disp(' id expt   method(s).....');
for icomb=1:size(coordnums_list,1)
    exptname=btc_exptname(dict.codel(coordnums_list(icomb,:)),dict);
    outstring=sprintf('%2.0f->%5s',icomb,exptname);
    if (isfield(pmethsum,exptname))
        allowed_pairs=[allowed_pairs,icomb];
        methods=getfield(pmethsum,exptname);
        for imeth=1:length(methods)
            outstring=cat(2,outstring,'   ',sprintf('%s %s',methods{imeth}.name,methods{imeth}.variant_lab));
        end
        disp(outstring);
    end
end
which_pairs=[];
while isempty(which_pairs)
    which_pairs=getinp('parameter pair(s) to use','d',[1 size(coordnums_list,1)]);
    which_pairs=intersect(which_pairs,allowed_pairs);
    if (isempty(which_pairs))
        disp('none of these are allowed pairs');
    end
end
pvsum=[];
npar=2;
nsteps=mapsize/ruleupdate;
%
for ipair=1:length(which_pairs)
    which_pair=which_pairs(ipair);
    exptname=btc_exptname(dict.codel(coordnums_list(which_pair,:)),dict);
    methods=getfield(pmethsum,exptname);
    for iv=1:npar
        icn(iv)=dict.codel(coordnums_list(which_pair,iv));
    end
    ic=char(icn);
    %set up mapping of display coordinates (x,y) to btc coordinates ic(1),ic(2)
    % x coordinate will display ic(itc(1)); y coordinate will display ic(itc(2))
    if (ipair==1)
        itc=[];
        for ip=1:npar
            if (ip==1)
                disp(' texture coordinate to be mapped across the image for first pair (values increasing from left to right)');
            else
                disp(' texture coordinate to be mapped down the image for first pair (values increasing from bottom to top)');
            end
            avail=setdiff([1:npar],itc);
            itc(ip)=getinp(sprintf('1->%s,2->%s',ic(1),ic(2)),'d',[min(avail) max(avail)],min(avail));
            prange(ip,:)=getinp(sprintf('range for parameter %1.0f (%s) [enter two values if nondefault]',...
                ip,ic(itc(ip))),'f',[-1 1],prange(ip,:));
        end
        across_vals=prange(1,1)+(prange(1,2)-prange(1,1))*([1:nsteps]-0.5)/nsteps;
        down_vals=prange(2,2)-(prange(2,2)-prange(2,1))*([1:nsteps]-0.5)/nsteps; %descending, from top of map
    end
    if (grayback==0)
        cnan=btc_getcolor(ic,setfield([],'pale',pale));
    else
        cnan=repmat(grayback,1,3);
    end
    imeth=1;
    %
    tstring=sprintf('%2.0f->%s %s %s',which_pair,exptname,methods{imeth}.name,methods{imeth}.variant_lab);
    disp(cat(2,'processing ',tstring));
    if (pixelrep>0)
        mapfilename=cat(2,mapfilestub,'_',exptname,'.',mapformat);
        disp(sprintf(' saved map name will be %s',mapfilename));
    end
    %
    % set up coarse-grained coordinates, and then set up cell array of rv's from each
    %
    % arrays are set up so that they will display properly in 
    % standard call to imagesc
    %
    rv_method=cell(nsteps,nsteps);
    ifok=zeros(nsteps,nsteps);
    btc_vals=zeros(nsteps,nsteps,length(dict.codel));
    for across=1:nsteps
        for down=1:nsteps
            spec=[];
            xy(1)=across_vals(across);
            xy(2)=down_vals(down);
            for ip=1:npar
                spec=setfield(spec,ic(itc(ip)),xy(ip));
            end
            rv=btc_augcoords(spec,dict,opts_augcoords);
            % get the texture generation method for this step
            rv_method{down,across}=rmfield(rv.method{imeth},{'letcode','corrs','cig_conds'});
            if (rv_method{down,across}.ok_norm==1) & (rv_method{down,across}.ok_probs==1)
                ifok(down,across)=1;
            end
            xparam(down,across)=xy(1);
            yparam(down,across)=xy(2);
            btc_vals(down,across,:)=rv_method{down,across}.vec;
        end %down
    end %across
    disp('coarse-grain coordinates and rules are set up.');
    map=repmat(NaN,mapsize,mapsize); %set up the map
    %create the map
    method_name=rv_method{1,1}.name;
    method_variant_num=rv_method{1,1}.variant_num;
    method_variant_lab=rv_method{1,1}.variant_lab;
    switch method_name
        case 'Pickard'
            nrot=NaN; %rotations done here
            %appropriate for NWSE
            steps=[0 1;1 0]; 
            begin=[0 0];
            begin_fine=[0 0];
            %  A B 
            %  C ?
            recurs=[1 1;1 0;0 1]; %A is at [row-1,col-1]; B is at [row-1, col], C is at [row, col-1]
            recurlet=[1 2 3]; % recursion knows about A, B, C
            pfield='p2x2';
            %appropriate for NESW
            if (method_variant_num==2)
                steps=[0 -1;1 0];
                begin=[0 nsteps-1];
                begin_fine=[0 ruleupdate-1];
                %  A B 
                %  ? D
                recurs=[1 0;1 -1;0 -1];
                recurlet=[1 2 4]; % recursion knows about A, B, D
                pfield='p2x2';
            end
        case 'DiagMRF'
            nrot=NaN; %rotations done ere
            %    B
            %   A D 
            %    ?
            steps=[0 1;1 0]; 
            begin=[0 0];
            begin_fine=[0 0];
            recurs=[1 1;2 0;1 -1]; % recursion knows about A, B, D
            recurlet=[1 2 4]; % recursion knows about A, B, C
            pfield='diagp2x2';
        case 'NoPickTT'
            nrot=method_variant_num-1; %rotations done below
            %appropriate for rot1
            steps=[0 1;1 0]; 
            begin=[0 0];
            begin_fine=[0 0];
            recurs=[1 1;1 0;0 1]; %A is at [row-1,col-1]; B is at [row-1, col], C is at [row, col-1]
            %  A B 
            %  C ?
            if (nrot==0) recurlet=[1 2 3];end % recursion knows about A, B, C
            %  A ? 
            %  C D
            if (nrot==1) recurlet=[3 1 4];end % recursion knows about C, A, D
            %  ? B 
            %  C D
            if (nrot==2) recurlet=[4 3 2];end % recursion knows about D, C, B
            %  A B 
            %  ? D
            if (nrot==3) recurlet=[2 4 1];end % recursion knows about B, D, A
            pfield='p2x2';
        case 'NoPickBT'
            nrot=method_variant_num-1; %rotations done below
            %appropriate for rot1
            steps=[0 1;1 0]; 
            begin=[0 0];
            begin_fine=[0 0];
            %  from genmrfm_tee
            %   A B C
            %     ?
            recurs=[1 1;1 0;1 -1]; %A is at [row-1,col-1]; B is at [row-1, col], C is at [row-1, col+1]
            recurlet=[1 2 3]; % recursion knows about A, B, C
            pfield='teeprobs';
    end
    if (nrot>0) %rot=0: no rotation; 
        for irot=1:nrot
            %begin(1)=nsteps-1-begin(2);
            %begin(2)=begin(1);
            begin=[nsteps-1 0]+[-1 1].*fliplr(begin);
            begin_fine=[ruleupdate-1 0]+[-1 1].*fliplr(begin_fine);
            steps=steps*[0 1;-1 0];
            recurs=recurs*[0 1;-1 0];
        end
    end
    %vector values for upper left to lower right, appropriate for Pickard NWSE
    for ix2=0:nsteps-1
        for ix1=0:nsteps-1
            coarse_loc=begin+steps(1,:)*ix1+steps(2,:)*ix2;
            if (ifok(1+coarse_loc(1),1+coarse_loc(2))==1);
                p2x2=getfield(rv_method{1+coarse_loc(1),1+coarse_loc(2)},pfield);
                fine_loc=begin_fine+coarse_loc*ruleupdate;
                for jx2=0:ruleupdate-1;
                    for jx1=0:ruleupdate-1;
                        cur_loc=fine_loc+steps(1,:)*jx1+steps(2,:)*jx2;
                        %find positions of checks to be used for recurrence
                        posits=repmat(cur_loc,3,1)-recurs;
                        probs=p2x2;
                        for ipos=1:size(posits,1)
                            have_val=0;
                            if (any(posits(ipos,:)<0)) | (any(posits(ipos,:)>=mapsize))
                                have_val=NaN;
                            else
                                have_val=map(1+posits(ipos,1)+mapsize*posits(ipos,2));
                            end
                            %marginalize or select
                            if (isnan(have_val))
                                probs=sum(probs,recurlet(ipos));
                            else
                                if (recurlet(ipos)==1) probs=probs(have_val+1,:,:,:); end
                                if (recurlet(ipos)==2) probs=probs(:,have_val+1,:,:); end
                                if (recurlet(ipos)==3) probs=probs(:,:,have_val+1,:); end
                                if (recurlet(ipos)==4) probs=probs(:,:,:,have_val+1); end
                            end
                        end %ipos
                        probs=squeeze(probs);
                        map(1+cur_loc(1),1+cur_loc(2))=double((rand(1)*sum(probs))>probs(1));
                    end %jx1
                end %jx2
            end %rule is OK at coarse location
            %if (ifok(coarse_loc(1)+1,coarse_loc(2)+1)==1);
            %    map(fine_loc(1)+[1:ruleupdate],fine_loc(2)+[1:ruleupdate])=round(rand(ruleupdate,ruleupdate));
            %end
        end
    end
    map(find(isnan(map)))=0.5;
    %
    if (if_plotd==1)
        %plot some setup info
        figure;
        set(gcf,'Position',[100 150 1200 800]);
        set(gcf,'NumberTitle','off');
        set(gcf,'Name',cat(2,'accessible region for ',ic));
        % create a color map in which the inner half is a color scale, bottom is white, top is black
        cmap=colormap(jet(256));
        cmap_bw=[ones(size(cmap,1)/4,3);cmap([1:2:size(cmap,1)-1],:);zeros(size(cmap,1)/4,3)];
        colormap(cmap_bw);
        %
        %plotting is tricky:  want to use default YDir='reverse' for imagesc, but want the parameter
        %values to be largest at top of map, which is row 1, so we flip and negate the y-values for plotting
        %
        for whichplot=1:3
            for inner=1:2
                subplot(2,3,whichplot+3*(inner-1));
                switch whichplot
                    case 1
                        tstring='ifok';
                        v=ifok;
                        zrange=[0 1];
                    case 2
                        tstring='xparam';
                        v=xparam*0.5; %the inner half is mapped to a color scale
                        zrange=[-1 1];
                    case 3
                        tstring='yparam';
                        v=yparam*0.5; %the inner half is mapped to a color scale
                        zrange=[-1 1];
                end
                imagesc(across_vals,-down_vals,v,zrange); hold on;
                title(tstring);
                if (inner==1)
                    tvals=prange;
                else
                    tvals=[-1 1;-1 1];
                end
                set(gca,'XLim',tvals(1,:));
                set(gca,'XTick',tvals(1,:)*tickmat)
                set(gca,'XTickLabel',tvals(1,:)*tickmat)
                set(gca,'YLim',-fliplr(tvals(2,:)));
                set(gca,'YTick',-fliplr(tvals(2,:))*tickmat);
                set(gca,'YTickLabel',fliplr(tvals(2,:))*tickmat);
                xlabel(ic(itc(1)));
                ylabel(ic(itc(2)));
                axis square;
            end %inner
        end %whichplot
    end %if_plotd
    %
    if (if_plotc)
        figure;
        % create a color map in which the inner half is a color scale, bottom is white, top is black
        set(gcf,'Position',[100 150 1200 800]);
        set(gcf,'NumberTitle','off');
        set(gcf,'Name',cat(2,'coordinate values for ',ic));
        cmap=colormap(jet(256));
        cmap_bw=[ones(size(cmap,1)/4,3);cmap([1:2:size(cmap,1)-1],:);zeros(size(cmap,1)/4,3)];
        colormap(cmap_bw);
        [nr,nc]=nicesubp(length(dict.codel),0.7);
        for iparam=1:length(dict.codel)
            subplot(nr,nc,iparam);
            tstring=sprintf('value of %s',dict.codel(iparam));
            % show coordinate value if ifok=1, otherwise, -1
            v=ifok.*btc_vals(:,:,iparam)*0.5+ifok-1; %ifok=1: btc_vals*0.5; otherwise, -1
            zrange=[-1 1];
            imagesc(across_vals,-down_vals,v,zrange); hold on;
            title(tstring);
            tvals=prange;
            set(gca,'XLim',tvals(1,:));
            set(gca,'XTick',tvals(1,:)*tickmat)
            set(gca,'XTickLabel',tvals(1,:)*tickmat)
            set(gca,'YLim',-fliplr(tvals(2,:)));
            set(gca,'YTick',-fliplr(tvals(2,:))*tickmat);
            set(gca,'YTickLabel',fliplr(tvals(2,:))*tickmat);
            xlabel(ic(itc(1)));
            ylabel(ic(itc(2)));
            axis square;
        end
    end %if_plotc
    %
    if (if_plotm)
        figure;
        % create a domain map
        set(gcf,'Position',[150 150 800 800]);
        set(gcf,'NumberTitle','off');
        set(gcf,'Name',cat(2,'map of domain for ',ic));
        cmap=colormap(gray(256));
        cmap_mod=cmap;
        cmap_mod(round(size(cmap,1)/2)+[-1:1],:)=repmat(cnan,3,1);
        colormap(cmap_mod);
        %
        across_vals_hr=prange(1,1)+(prange(1,2)-prange(1,1))*([1:mapsize]-0.5)/mapsize;
        down_vals_hr=prange(2,2)-(prange(2,2)-prange(2,1))*([1:mapsize]-0.5)/mapsize; %descending, from top of map
        tstring=cat(2,'domain for ',ic);
        imagesc(across_vals_hr,-down_vals_hr,map,[0 1]); hold on;
        title(tstring);
        tvals=prange;
        set(gca,'XLim',tvals(1,:));
        set(gca,'XTick',tvals(1,:)*tickmat)
        set(gca,'XTickLabel',tvals(1,:)*tickmat)
        set(gca,'YLim',-fliplr(tvals(2,:)));
        set(gca,'YTick',-fliplr(tvals(2,:))*tickmat);
        set(gca,'YTickLabel',fliplr(tvals(2,:))*tickmat);
        xlabel(ic(itc(1)));
        ylabel(ic(itc(2)));
        axis square;
    end %if_plotm
    if (pixelrep>0)
        imwrite(reppxl(map*256,[pixelrep pixelrep]),cmap_mod,mapfilename,mapformat);
        disp(sprintf('map %s written.',mapfilename));
    end
end %ipair
%
clear inner whichplot v tstring zrange tvals xy 
clear spec outstring across down iparam nr nc ipair
clear iv ix1 ix2 jx1 jx2 ipos
clear coarse_loc fine_loc have_vals

